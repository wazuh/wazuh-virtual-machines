run-name: Build AMI - Wazuh virtual machines ${{ inputs.id }} - Branch ${{ github.ref_name }} - Launched by @${{ github.actor }}
name: Build AMI

on:
  workflow_dispatch:
    inputs:
      id:
        description: "ID used to identify the workflow uniquely."
        type: string
        required: false
      wazuh_virtual_machines_reference:
        description: 'Branch or tag of the wazuh-virtual-machines repository'
        required: true
      wazuh_automation_reference:
        description: 'Branch or tag of the wazuh-automation repository'
        required: true
        default: 'main'
      is_stage:
        description: "Is stage?"
        type: boolean
        default: false
        required: false
      ami_revision:
        description: |
          'For AMI candidates must be a number, e,g: -1.'
          'To build a development AMI, use another revision format, e.g: -dev'
        required: false
        default: '-1'
      wazuh_package_type:
        description: 'Wazuh package type to be used in the AMI'
        required: true
        default: 'dev'
        type: choice
        options:
          - prod
          - pre-prod
          - dev
      architecture:
        description: |
          'Determine the architecture. It must be a string list (JSON format). E.g: ["amd64", "arm64"]'
        required: true
        default: '["amd64", "arm64"]'
        type: string
      commit_list:
        description: |
          'Wazuh components revisions (comma-separated string list) ["indexer-revision", "server-revision", "dashboard-revision", "agent-revision", "assistant-revision"]'
          (Only needed if the Wazuh package type is dev)
        required: true
        default: '["latest", "latest", "latest", "latest", "latest"]'
        type: string
      customizer_debug:
        description: 'Enable debug mode in the AMI customizer'
        required: false
        default: false
        type: boolean
      issue:
        description: 'URL of the GitHub issue related to this build'
        required: false
        type: string
      destroy:
        description: 'Destroy the base instance after the AMI is created'
        required: false
        default: true
        type: boolean
  workflow_call:
    inputs:
      id:
        type: string
        required: false

env:
    ALLOCATOR_PATH: "/tmp/allocatorvm_ami"
    WORKFLOW_VENV: "${{ github.workspace }}/workflow_venv"
    COMMIT_LIST: ${{ inputs.commit_list }}
    PROD_ARTIFACTS_URLS_BUCKET: ${{ vars.AWS_S3_BUCKET_PROD }}
    PRE_PROD_ARTIFACTS_URLS_BUCKET: ${{ vars.AWS_S3_BUCKET_PRE }}
    DEV_ARTIFACTS_URLS_BUCKET: ${{ vars.AWS_S3_BUCKET_ARTIFACTS }}
    ARTIFACTS_URLS_FILENAME: "artifact_urls_test.yml"
    DEV_ARTIFACTS_URLS_PATH: "deployment"
    GENERATE_PRESIGNED_URLS_SCRIPT_PATH: ${{ github.workspace }}/.github/scripts/generate_presigned_dev_urls.py
    CUSTOMIZER_SERVICE_FILE: ${{ github.workspace }}/configurer/ami/ami_pre_configurer/scripts/wazuh-ami-customizer.service

permissions:
  id-token: write
  contents: read

jobs:
  Build_AMI:
    runs-on: ubuntu-22.04
    strategy:
      fail-fast: false    # If a job fails, the rest of jobs will not be canceled
      matrix:
        arch: ${{ fromJson(inputs.architecture) }}

    steps:
      - name: View parameters
        run: echo "${{ toJson(inputs) }}"

      - name: Validate Issue URL
        if: inputs.issue != ''
        run: |
          ISSUE_URL="${{ inputs.issue }}"
          # Regex to check for a valid URL starting with https://github.com/wazuh/
          if [[ "$ISSUE_URL" =~ ^https://github\.com/wazuh/.* ]]; then
            echo "Valid Wazuh GitHub issue URL provided."
            echo "ISSUE_TAG_KEY=Issue" >> $GITHUB_ENV
            echo "ISSUE_TAG_VALUE=$ISSUE_URL" >> $GITHUB_ENV
          else
            echo "::warning::The provided issue URL is not valid or does not belong to the Wazuh project."
          fi

      - name: Checkout wazuh/wazuh-virtual-machines repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.wazuh_virtual_machines_reference }}

      - name: Checkout wazuh/wazuh-automation repository
        uses: actions/checkout@v4
        with:
          repository: wazuh/wazuh-automation
          ref: ${{ inputs.wazuh_automation_reference }}
          token: ${{ secrets.GH_CLONE_TOKEN }}
          path: wazuh-automation

      - name: Configure aws credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AWS_IAM_OVA_ROLE }}
          aws-region: us-east-1

      - name: Install and configure python and workflow dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          sudo wget -q https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq
          sudo apt-get install -y python3 python3-venv
          python3 -m venv ${{ env.WORKFLOW_VENV }}
          source ${{ env.WORKFLOW_VENV }}/bin/activate
          pip install --upgrade pip
          pip install hatch pyyaml

      - name: Get Wazuh version
        run: |
          WAZUH_VERSION=$(jq -r '.version' VERSION.json)
          WAZUH_MAJOR=$(echo "$WAZUH_VERSION" | cut -d '.' -f 1)
          WAZUH_MINOR=$(echo "$WAZUH_VERSION" | cut -d '.' -f 1-2)
          COMMIT_SHA=$(git rev-parse --short ${{ github.sha }})

          ARCH_FLAG=""
          ARCH_SUFFIX=""
          if [[ "${{ matrix.arch }}" == "arm64" ]]; then
            ARCH_FLAG="--arch aarch64"
            ARCH_SUFFIX="_aarch64"
          else
            ARCH_SUFFIX="_x86_64"
          fi

          if [ ${{ inputs.is_stage }} == true ]; then
            # Stage build: Wazuh_v5.0.0-1_x86_64
            AMI_NAME="Wazuh_v${WAZUH_VERSION}-${{ inputs.ami_revision }}${ARCH_SUFFIX}"
          else
            # Dev builds: commit versions
            AMI_NAME="Wazuh_v${WAZUH_VERSION}-${{ inputs.ami_revision }}-${COMMIT_SHA}${ARCH_SUFFIX}"
          fi

          COMPOSITE_NAME="amazon-2023-${{ matrix.arch }}"
          echo COMPOSITE_NAME=$COMPOSITE_NAME >> $GITHUB_ENV
          echo ARCH_FLAG=$ARCH_FLAG >> $GITHUB_ENV
          echo AMI_NAME=$AMI_NAME >> $GITHUB_ENV
          echo WAZUH_VERSION=$WAZUH_VERSION >> $GITHUB_ENV
          echo WAZUH_MAJOR=$WAZUH_MAJOR >> $GITHUB_ENV
          echo WAZUH_MINOR=$WAZUH_MINOR >> $GITHUB_ENV
          echo ARCH_SUFFIX=$ARCH_SUFFIX >> $GITHUB_ENV

      - name: Install and set allocator requirements
        run: |
          pip install -r wazuh-automation/deployability/deps/requirements.txt

      - name: Execute allocator module that will create the base instance
        id: alloc_vm_ami
        run: |
          python wazuh-automation/deployability/modules/allocation/main.py --action create --provider aws --size large --composite-name ${{ env.COMPOSITE_NAME }} --working-dir ${{ env.ALLOCATOR_PATH }} \
            --track-output ${{ env.ALLOCATOR_PATH }}/track.yml --inventory-output ${{ env.ALLOCATOR_PATH }}/inventory.yml --instance-name gha_${{ github.run_id }}_ami_build \
            --label-team devops --label-termination-date 1d
          INSTANCE_ID=$(yq '.all.hosts | keys | .[0]' ${{ env.ALLOCATOR_PATH }}/inventory.yml)
          echo INSTANCE_ID=$INSTANCE_ID >> $GITHUB_ENV

      - name: Get artifacts URLs file
        run: |
          LOCAL_ARTIFACTS_URLS_FILEPATH=${{ github.workspace }}/${{ env.ARTIFACTS_URLS_FILENAME }}
          echo LOCAL_ARTIFACTS_URLS_FILEPATH=$LOCAL_ARTIFACTS_URLS_FILEPATH >> $GITHUB_ENV

          if [ "${{ inputs.wazuh_package_type }}" == "prod" ]; then
            aws s3api get-object --bucket ${{ env.PROD_ARTIFACTS_URLS_BUCKET }} --key ${{ env.WAZUH_MINOR }}/${{ env.ARTIFACTS_URLS_FILENAME }} $LOCAL_ARTIFACTS_URLS_FILEPATH
          elif [ "${{ inputs.wazuh_package_type }}" == "pre-prod" ]; then
            aws s3api get-object --bucket ${{ env.PRE_PROD_ARTIFACTS_URLS_BUCKET }} --key ${{ env.WAZUH_MINOR }}/${{ env.ARTIFACTS_URLS_FILENAME }} $LOCAL_ARTIFACTS_URLS_FILEPATH
          else
            LOCAL_AWS_S3_BUCKET_DEV=${{ vars.AWS_S3_BUCKET_DEV }}
            echo LOCAL_AWS_S3_BUCKET_DEV=$LOCAL_AWS_S3_BUCKET_DEV >> $GITHUB_ENV
            aws s3api get-object --bucket ${{ env.DEV_ARTIFACTS_URLS_BUCKET }} --key ${{ env.DEV_ARTIFACTS_URLS_PATH }}/${{ env.ARTIFACTS_URLS_FILENAME }} $LOCAL_ARTIFACTS_URLS_FILEPATH
          fi

      - name: Generate presigned URLs for artifacts for dev packages
        if: inputs.wazuh_package_type == 'dev'
        run: |
          python ${{ env.GENERATE_PRESIGNED_URLS_SCRIPT_PATH }}

      - name: Set customizer debug mode environment variable
        if: inputs.customizer_debug == true
        run: |
          sed -i 's|ExecStart=.* -m wazuh-ami-customizer$|& --debug|' ${{ env.CUSTOMIZER_SERVICE_FILE }}

      - name: Execute configuration AMI process
        run: |
          source ${{ env.WORKFLOW_VENV }}/bin/activate
          hatch run dev:run --inventory ${{ env.ALLOCATOR_PATH }}/inventory.yml --packages-url-path ${{ env.LOCAL_ARTIFACTS_URLS_FILEPATH }} --execute all-ami ${{ env.ARCH_FLAG }}

      - name: Stop instance
        run: |
          aws ec2 stop-instances --instance-ids ${{ env.INSTANCE_ID }}

      - name: Check EC2 instance status until stopped
        id: check_status
        run: |
          TIMEOUT=120
          INTERVAL=2
          ELAPSED=0

          while [ $ELAPSED -lt $TIMEOUT ]; do
            STATUS=$(aws ec2 describe-instances --instance-ids ${{ env.INSTANCE_ID }} --query 'Reservations[*].Instances[*].State.Name' --output text)
            echo "Instance status: $STATUS"

            if [ "$STATUS" == "stopped" ]; then
              echo "Instance is stopped."
              break
            fi

            echo "Waiting for instance to stop..."
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "Timeout reached. The instance is still not stopped."
            exit 1
          fi

      - name: Build AMI from instance
        if: success()
        run: |
          # Create AMI
          aws ec2 create-image --instance-id ${{ env.INSTANCE_ID }} --name "${{ env.AMI_NAME }}" --no-reboot
          AMI_ID=$(aws ec2 describe-images --filters "Name=name,Values=${{ env.AMI_NAME }}" --query 'Images[*].ImageId' --output text)
          echo "AMI_ID=$AMI_ID" >> $GITHUB_ENV
          echo "AMI creation started with name ${{ env.AMI_NAME }}"

      - name: Check AMI status until available
        id: check_ami_status
        run: |
          TIMEOUT=1800
          INTERVAL=30
          ELAPSED=0

          # Function to check AMI status
          check_ami() {
            local ami_id=$1
            local ami_name=$2

            echo "Checking status for AMI: $ami_name ($ami_id)"

            while [ $ELAPSED -lt $TIMEOUT ]; do
              STATUS=$(aws ec2 describe-images --image-ids $ami_id --query 'Images[*].State' --output text)
              echo "AMI $ami_name status: $STATUS"

              if [ "$STATUS" == "available" ]; then
                echo "AMI $ami_name is available."
                return 0
              fi

              echo "Waiting for AMI $ami_id to be available..."
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
            done

            echo "Timeout reached. The AMI $ami_id is still not available."
            return 1
          }

          # Check AMI
          check_ami "${{ env.AMI_ID }}" "${{ env.AMI_NAME }}"

      - name: Tag AMI
        if: success()
        run: |
          if [ "${{ inputs.is_stage }}" == "true" ]; then
            DEV_TAG_VALUE="False"
          else
            DEV_TAG_VALUE="True"
          fi

          # Tag AMI
          TAGS="Key=Name,Value=${{ env.AMI_NAME }} Key=Dev,Value=$DEV_TAG_VALUE Key=WorkflowRun,Value=${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          if [ -n "${{ env.ISSUE_TAG_KEY }}" ]; then
            TAGS="$TAGS Key=${{ env.ISSUE_TAG_KEY }},Value=${{ env.ISSUE_TAG_VALUE }}"
          fi

          aws ec2 create-tags --resources ${{ env.AMI_ID }} --tags $TAGS
          echo "Tagged AMI ${{ env.AMI_ID }} with tags: $TAGS"

      - name: Delete allocated VM
        if: always() && steps.alloc_vm_ami.outcome == 'success' && inputs.destroy == true
        run: python3 wazuh-automation/deployability/modules/allocation/main.py --action delete --track-output ${{ env.ALLOCATOR_PATH }}/track.yml

      - name: Compress Allocator directory
        id: generate_artifacts
        if: always() && steps.alloc_vm_ami.outcome == 'success' && inputs.destroy == false
        run: zip -P "${{ secrets.ZIP_ARTIFACTS_PASSWORD }}" -r ${{ env.ALLOCATOR_PATH }}.zip ${{ env.ALLOCATOR_PATH }}
        continue-on-error: true

      - name: Upload Allocator directory as artifact
        if: always() && steps.generate_artifacts.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: instance_info${{ env.ARCH_SUFFIX }}
          path: ${{ env.ALLOCATOR_PATH }}.zip
